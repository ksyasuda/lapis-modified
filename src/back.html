<!---------- Header ------------->
<header>
    <div class="top-container">
        <!-- Show the frequency number -->
        {{FreqSort}}

        <!-- The frequency list -->
        {{#Frequency}}
        <span class="freq-dropdown">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width="15"
                height="15"
                class="dropdown-arrow-svg"
                viewBox="0 0 16 16"
            >
                <path
                    d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"
                ></path>
                <path d="M 12.7,6.5 H 3.3 L 8,11 Z"></path>
            </svg>
            <div class="freq-list-container">{{Frequency}}</div>
        </span>
        {{/Frequency}}
    </div>
</header>

<main lang="ja">
    <div class="template">

        <!-- The first row -->
        <div class="def-header">
            <div class="dh-left">
                <div class="vocab">
                    {{#ExpressionFurigana}}{{furigana:ExpressionFurigana}}{{/ExpressionFurigana}}
                    {{^ExpressionFurigana}}{{Expression}}{{/ExpressionFurigana}}
                </div>

                <!-- Reading + Pitch Accent -->
                <div class="info">
                    <div class="pitch">
                        {{#ExpressionFurigana}}{{kana:ExpressionFurigana}}{{/ExpressionFurigana}}
                        {{^ExpressionFurigana}}{{ExpressionReading}}{{/ExpressionFurigana}}
                    </div>

                    <!-- Pitch Accent -->
                    {{#PitchPosition}}
                    <span id="pitch-tags" class="tags"> {{PitchPosition}} </span>
                    {{/PitchPosition}}
                </div>
            </div>
        </div>

        <br>

        <!-- The entire definition box -->
        <div class="def-info">First Definition 1/?</div>
        <div class="main-def">
            <div class="edge tappable" id="edge-prev" onclick="changeIndex(-1)"></div>
            <div class="edge tappable" id="edge-next" onclick="changeIndex(1)"></div>
            {{#DefinitionPicture}}
            <div class="def-image tappable">{{DefinitionPicture}}</div>
            {{/DefinitionPicture}}
            <div class="definition">
                {{#SelectionText}}
                <div id="selection" data-display-name="Text Selection">{{SelectionText}}</div>
                {{/SelectionText}}
                {{#MainDefinition}}
                <div id="primary" data-display-name="Primary Definition">{{MainDefinition}}</div>
                {{/MainDefinition}}
                <div id="glossaries" data-display-name="Glossaries">{{Glossary}}</div>
                <!-- New definition for WaniAnki -->
                <div id="wanianki" data-display-name="WaniAnki">
                  <span id="word" style="display: none;">{{Expression}}</span>
                  <div id="kanjiInfo"></div>
                </div>
                <!-- AI Translation Section -->
                <div id="ai-translation" data-display-name="AI Translation" class="hidden">
                  <div id="translation-result">Click to translate: {{Expression}}</div>
                </div>
            </div>
        </div>

        <!-- Image (MODIFIED)-->
        {{#Picture}}
        <div class="image-container">
            <div class="image tappable {{Tags}}">{{Picture}}</div>
        </div>
        {{/Picture}}

        <!-- Sentence Moved (MODIFIED)-->
        <div class="sentence">
            {{#SentenceFurigana}} {{furigana:SentenceFurigana}} {{/SentenceFurigana}}
            {{^SentenceFurigana}} {{furigana:Sentence}} {{/SentenceFurigana}}
        </div>

        <!-- This is for the sentence that you see on mobile (positioned under definition), on Desktop, the sentence goes above the definition box, and this is hidden -->
        <div class="sentence-mobile">
            {{#SentenceFurigana}} {{furigana:SentenceFurigana}} {{/SentenceFurigana}}
            {{^SentenceFurigana}} {{furigana:Sentence}} {{/SentenceFurigana}}
        </div>

		<!-- Audio Buttons Moved (MODIFIED)-->
        <br />
        <div class="audio-buttons">{{ExpressionAudio}} {{SentenceAudio}}</div>

        <!------- Image modal --------->
        <div class="modal-bg tappable">
            <div class="img-popup"></div>
        </div>

        {{#MiscInfo}}
        <details>
            <summary>Misc. info</summary>
            <div class="misc-info">
                === Details ===
                <br />
                {{MiscInfo}}
            </div>
        </details>
        {{/MiscInfo}}
</main>

<!----------- Footer ------------->
<footer lang="ja">
    <br>
    <div class="bot-container">
        {{#Tags}}
        <div class="tags-container">
            <div class="tags">{{Tags}}</div>
        </div>
        {{/Tags}}
    </div>
</footer>

<!----------- Scripts ------------>
<script>
    // This code is concerned with calculating the Pitch Accent and constructing the pitch accent graphs
    function isOdaka(pitchNumber) {
        const kana = `{{kana:ExpressionFurigana}}` || `{{ExpressionReading}}`;
        return (
            kana !== null &&
            kana.replace(/[ァィゥェォャュョヮぁぃぅぇぉゃゅょゎ]/g, '').length ===
                pitchNumber
        );
    }

    function getPitchCategories() {
        const validTypes = '(heiban|atamadaka|nakadaka|odaka|kifuku)';
        return [...`{{PitchCategories}}`.matchAll(validTypes)].map((m) => m[0]);
    }

    function hasVerbOrAdjEnding() {
        const endings = ['い', 'う', 'く', 'す', 'つ', 'ぶ', 'む', 'る'];
        return endings.some((ending) =>
            `{{Expression}}`.replace('</div>', '').endsWith(ending)
        );
    }

    function getPitchType(pitchPosition) {
        const pitchCategories = getPitchCategories();
        const kifukuTags = [
            'adj-i',
            'v1',
            'v2',
            'v4',
            'v5',
            'vs-',
            'vz',
            'vk',
            'vn',
            'vr'
        ];
        let canBeKifuku = pitchCategories.includes('kifuku');
        canBeKifuku ||= kifukuTags.some((tag) => `{{PitchCategories}}`.includes(tag));
        if (canBeKifuku || (pitchCategories.length == 0 && hasVerbOrAdjEnding())) {
            return pitchPosition === 0 ? "heiban" : "kifuku";
        }

        if (pitchPosition === 0) {
            return "heiban";
        } else if (pitchPosition === 1) {
            return "atamadaka";
        } else if (pitchPosition > 1) {
            return isOdaka(pitchPosition) ? "odaka" : "nakadaka";
        }
    }

    function handlePitches() {
        const pitchTags = document.querySelector('#pitch-tags');
        const pitchPositions = pitchTags?.textContent
            .match(/^\d+|\d+\b|\d+(?=\w)/g)
            .map(Number);
        if (!pitchPositions) return;

        paintTargetWord(getPitchType(pitchPositions[0]));
        constructPitch(new Set(pitchPositions));
    }

    // Show the color
    function paintTargetWord(pitchType) {
        const sentences = Array.from(
            document.querySelectorAll(".sentence, .definition, .sentence-mobile"),
        );
        for (const sentence of sentences) {
            for (const targetWord of sentence.getElementsByTagName("b")) {
                targetWord.classList.add(pitchType);
            }
        }

        const vocabElement = document.querySelector(".vocab");
        if (vocabElement !== null) {
            vocabElement.classList.add(pitchType);
        }
    }

    // Seperate Tags by space, and show them in their own boxes
    function splitTags() {
        const tagsContainer = document.querySelector(".tags-container");
        if (!tagsContainer) return;
        const tags = `{{Tags}}`.split(' ');
        tagsContainer.innerHTML = tags
            .map((tag) => `<div class="tags">${tag}</div>`)
            .join('');
    }

    function groupMoras(kana) {
        let currentChar = "";
        let nextChar = "";
        const groupedMoras = [];
        const check = [
            'ァ',
            'ィ',
            'ゥ',
            'ェ',
            'ォ',
            'ャ',
            'ュ',
            'ョ',
            'ヮ',
            'ぁ',
            'ぃ',
            'ぅ',
            'ぇ',
            'ぉ',
            'ゃ',
            'ゅ',
            'ょ',
            'ゎ'
        ];

        for (let i = 0; i < kana.length; i++) {
            currentChar = kana[i];
            nextChar = i < kana.length - 1 && kana[i + 1];
            if (check.includes(nextChar)) {
                groupedMoras.push(currentChar + nextChar);
                i += 1;
            } else {
                groupedMoras.push(currentChar);
            }
        }
        return groupedMoras;
    }

    function getPitchPattern(pitchPosition) {
        // 0 = low
        // 1 = high
        // 2 = high to low

        const kana = `{{kana:ExpressionFurigana}}` || `{{ExpressionReading}}`;
        const moras = groupMoras(kana);
        let pattern = [];

        if (pitchPosition === 0) {
            // 平板
            pattern = [
                ...Array(moras[0].length).fill("0"),
                ...Array(kana.length - moras[0].length).fill("1"),
            ];
        } else if (pitchPosition === 1) {
            // 頭高
            pattern = [
                ...(moras[0].length === 2 ? ["1", "2"] : ["2"]),
                ...Array(kana.length - moras[0].length).fill("0"),
            ];
        } else if (pitchPosition > 1) {
            if (isOdaka(pitchPosition)) {
                // 尾高
                pattern = [
                    ...Array(moras[0].length).fill("0"),
                    ...Array(kana.length - moras[0].length - 1).fill("1"),
                    "2",
                ];
            } else {
                // 中高
                let afterDrop = false;
                for (let i = 0; i < moras.length; i++) {
                    if (i === 0) {
                        pattern = Array(moras[0].length).fill("0");
                    } else if (i + 1 === pitchPosition) {
                        pattern =
                            moras[i].length === 2
                                ? [...pattern, "1", "2"]
                                : [...pattern, "2"];
                        afterDrop = true;
                    } else if (afterDrop) {
                        pattern = [...pattern, ...Array(moras[i].length).fill("0")];
                    } else {
                        pattern = [...pattern, ...Array(moras[i].length).fill("1")];
                    }
                }
            }
        }
        return pattern;
    }

    function constructPitch(pitchPositions) {
        const kana = `{{kana:ExpressionFurigana}}` || `{{ExpressionReading}}`;
        const pitch = document.querySelector(".pitch");
        const pitchTags = document.querySelector("#pitch-tags");

        const createPitchSpan = (pitchClass, pitchChar) => {
            const pitchSpan = document.createElement("span");
            const charSpan = document.createElement("span");
            const lineSpan = document.createElement("span");

            pitchSpan.classList.add(pitchClass);
            charSpan.classList.add("pitch-char");
            charSpan.innerText = pitchChar;
            lineSpan.classList.add("pitch-line");

            pitchSpan.appendChild(charSpan);
            pitchSpan.appendChild(lineSpan);

            return pitchSpan;
        };

        pitch.innerHTML = "";
        pitchTags.innerHTML = "";
        pitchTags.style.display = "inline-block";
        const pitchList = document.createElement("ul");
        const pitchTagList = document.createElement("ul");

        for (let pitchPosition of pitchPositions) {
            const pitchTag = document.createElement("li");
            pitchTag.textContent = pitchPosition;

            const pattern = getPitchPattern(pitchPosition);

            const pitchItem = document.createElement("li");
            pitchItem.classList.add("pitch-item");
            pitchItem.classList.add(getPitchType(pitchPosition));

            for (let i = 0; i < kana.length; i++) {
                if (pattern[i] === "0")
                    pitchItem.appendChild(createPitchSpan("pitch-low", kana[i]));
                else if (pattern[i] === "1")
                    pitchItem.appendChild(createPitchSpan("pitch-high", kana[i]));
                else if (pattern[i] === "2")
                    pitchItem.appendChild(createPitchSpan("pitch-to-drop", kana[i]));
                else
                    console.error(
                        "pattern[i] found undefined value. pattern is",
                        pattern,
                    );
            }
            pitchTagList.appendChild(pitchTag);
            pitchList.appendChild(pitchItem);
        }

        pitch.appendChild(pitchList);
        pitchTags.appendChild(pitchTagList);
    }

    // Returns the dictionary content, without the dictionary name.
    function getDictionaryContent(dictionarySelector) {
        const dictionary = document.querySelector(dictionarySelector);
        if (!dictionary) return null;
        const contentInSpan = dictionary.querySelector(":scope > span");
        if (contentInSpan) return contentInSpan;

        const hasDictName = dictionary.querySelector(":scope > i");
        if (!hasDictName) return dictionary;

        let dictionaryCopy = dictionary.cloneNode(true);
        dictName = dictionaryCopy.querySelector(":scope > i");
        dictName.remove();
        return dictionaryCopy;
    }

    function isPrimaryEqualToGloss() {
        const isJPMNConverted = document.querySelector(".definition li[data-details]");
        if (isJPMNConverted) return false;
        // single dict formatting
        const isSingleDict =
            document.querySelectorAll('#glossaries > div > ol').length === 0;
        if (isSingleDict) {
            const primaryDictName = document.querySelector("#primary > div > i");
            const glossariesDictName = document.querySelector("#glossaries > div > i");
            // Compare dicts names if present
            if (primaryDictName && glossariesDictName) {
                return primaryDictName.textContent === glossariesDictName.textContent;
            }
            // Compare content otherwise
            const primaryDict = getDictionaryContent("#primary > div");
            const glossariesDict = getDictionaryContent("#glossaries > div");
            if (!primaryDict || !glossariesDict ) return false;
            return primaryDict.innerHTML.trim() === glossariesDict.innerHTML.trim();
        }

        // multiple dicts
        const primaryDicts = document.querySelectorAll('#primary li[data-dictionary]');
        const glossariesDicts = document.querySelectorAll(
            '#glossaries li[data-dictionary]'
        );
        return primaryDicts.length === glossariesDicts.length;
    }

    // Removes Unnecessary definitions
    function cleanUpDefinitions() {
        let selection = document.getElementById("selection");
        let primary = document.getElementById("primary");
        let glossaries = document.getElementById("glossaries");
        if (selection && selection.textContent === "") {
            selection.remove();
        }
        if (primary && primary.textContent === "") {
            primary.remove();
            primary = null;
        }
        if (glossaries && glossaries.textContent === "") {
            glossaries.remove();
            glossaries = null;
        } else if (primary && glossaries && isPrimaryEqualToGloss()) {
            glossaries.remove();
        }
    }

    // Display definition corresponding to index
    function updateDefDisplay() {
        const definitions = document.querySelectorAll('.main-def > .definition > div');
        const indexDisplay = document.querySelector(".def-info");

        let n_defs = definitions.length;
        if (n_defs === 0) return;

        let currentIndex = Number(document.head.dataset.defIndex) || 0;
        currentIndex = currentIndex % n_defs;
        while (currentIndex < 0) currentIndex += n_defs;

        for (let idx = 0; idx < n_defs; idx++) {
            definitions[idx].classList.add('hidden');
        }
        definitions[currentIndex].classList.remove('hidden');

        const defDisplayName = definitions[currentIndex].dataset.displayName;
        if (indexDisplay) {
            indexDisplay.style.opacity = 1;
            indexDisplay.innerText = `${defDisplayName} ${currentIndex + 1}/${n_defs}`;
        }
    }

    function changeIndex(value) {
        // sync index between clicks and arrowkeys
        index = Number(document.head.dataset.defIndex);
        document.head.dataset.defIndex = index + value;
        updateDefDisplay();
    }

    function setUpDefToggle() {
        document.head.dataset.defIndex = 0;
        cleanUpDefinitions();

        // hide all but first definition
        let definitions = document.querySelectorAll('.main-def > .definition > div');
        Array.from(definitions)
            .slice(1)
            .forEach((def) => {
                def.classList.add('hidden');
            });

        // Always show the first definition and update the display
        if (definitions.length > 0) {
            definitions[0].classList.remove('hidden');
            updateDefDisplay();
        }

        // no need for toggling on less than 2 definitions
        if (definitions.length < 2) return;

        // Since <head> doesn't change through review sessions
        // Adding and checking for this class ensure each card doesn't add its own listener
        if (document.head.classList.contains('has-listener')) return;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changeIndex(-1);
            else if (e.key === 'ArrowRight') changeIndex(1);
        });

        document.head.classList.add("has-listener");
    }

    // Image lightbox with fade transition similar to JPMN
    function clickImages() {
        const modalBg = document.querySelector('.modal-bg');
        const imgPopup = document.querySelector('.img-popup');
        const images = Array.from(
            document.querySelectorAll('.image img, .def-image img')
        );

        if (images.length < 1) return;

        for (let image of images) {
            image.addEventListener("click", () => {
                const imgPopupContainer = document.createElement("div");
                const imgPopupImg = document.createElement("img");

                imgPopupContainer.classList.add("img-popup-container");
                imgPopupImg.src = image.src;
                imgPopupImg.classList.add("img-popup-img");

                if (image.height > image.width) {
                    imgPopupContainer.style.height = "calc(100% - 20px)";
                    imgPopupContainer.style.width = "max-content";
                }

                imgPopup.innerHTML = '';
                imgPopup.appendChild(imgPopupContainer);
                imgPopupContainer.appendChild(imgPopupImg);

                // Force a reflow before adding active classes to ensure transitions work
                void modalBg.offsetWidth;

                // Show the modal background with fade transition
                modalBg.style.display = 'block';

                // Force another reflow to ensure the display change takes effect before transition
                void modalBg.offsetWidth;

                modalBg.classList.add('active');
                imgPopupContainer.classList.add('active');
                document.body.classList.add('img-popup');
            });
        }

        modalBg.addEventListener('click', () => {
            // Removes active classes to trigger fade-out transition
            modalBg.classList.remove('active');
            const activeContainer = document.querySelector(
                '.img-popup-container.active'
            );
            if (activeContainer) {
                activeContainer.classList.remove('active');
            }
            setTimeout(() => {
                document.body.classList.remove('img-popup');
                modalBg.style.display = 'none';
                imgPopup.innerHTML = '';
            }, 300);
        });
    }

    // Format plaintext frequencies into a list
    function formatFrequencyList() {
        const frequency = document.querySelector('.freq-list-container');
        if (!frequency) return;
        const frequencyList = frequency.querySelector('ul');
        // Already a list; nothing to do
        if (frequencyList) return;

        const freqs = frequency.innerText.split(',');
        const freqHtml = `<ul>${freqs.map(freq => `<li>${freq.trim()}</li>`).join('')}</ul>`
        frequency.innerHTML = freqHtml;
    }

    // Sets the height of dhLeft, dhRight, defHeader as a whole
    function setDHHeight() {
        var dhLeft = document.querySelector('.dh-left');
        var dhRight = document.querySelector('.dh-right .image img');
        var defHeader = document.querySelector('.def-header')

        if (dhLeft && dhRight) {
            var dhLeftHeight = dhLeft.offsetHeight;
            dhRight.style.maxHeight = `${dhLeftHeight}px`;
            defHeader.style.maxHeight = `${dhLeftHeight}px`;
        }
    }

    // Hides the dictionaries user selected in MainDefinition in Glossary field, if any
    function hideCorrectDefinition() {
        // Do nothing if css rule already exists
        if (document.querySelector("style#hide-main-def")) return;

        let primaryDicts = document.querySelectorAll("#primary li[data-dictionary]");
        if (primaryDicts.length === 0) return;

        let style = document.createElement('style');
        style.type = 'text/css';
        style.id = "hide-main-def";

        const cssSelector = Array.from(primaryDicts)
            .map(
                (dict) => `#glossaries li[data-dictionary="${dict.dataset.dictionary}"]`
            )
            .join(', ');
        const cssRules = `${cssSelector} { display:none !important; }`;
        style.appendChild(document.createTextNode(cssRules));

        let defContainer = document.querySelector("blockquote.main-def");
        defContainer.appendChild(style);
    }

    // Moves Primary Dicts into the same list
    function movePrimaryDicts() {
        let primaryDicts = document.querySelectorAll('#primary li[data-dictionary]');
        let firstList = document.querySelector(
            '#primary .yomitan-glossary > ol:has( li[data-dictionary])'
        );
        for (let idx = 1; idx < primaryDicts.length; idx++) {
            firstList.appendChild(primaryDicts[idx]);
        }
    }

    // Initialize all functions!!!
    function initialize() {
        splitTags();
        handlePitches();
        setUpDefToggle();
        clickImages();
        formatFrequencyList();
        setDHHeight();
        hideCorrectDefinition();
        movePrimaryDicts();
    }

    initialize();
</script>

<!-- WaniAnki Scripts -->
<script>
    var apiToken = "YOU CAN LEAVE THIS AS IT IS OR ADD YOUR WANIKANI API KEY";
    var kanji = document.getElementById("word").textContent;
</script>
<script type="text/javascript" src="https://damiansh.github.io/js/jquery.min.js"></script>
<script src="https://damiansh.github.io/waniAnki/waniAnki.js"></script>
<link rel="stylesheet" href="https://damiansh.github.io/waniAnki/waniAnki.css">

<!-- AI Translation Script -->
<script>
    async function getAITranslation() {
        const translationResult = document.getElementById('translation-result');
        // Always get the current card's expression
        const inputText = document.querySelector('.vocab').textContent.trim();

        // Show we're working on it
        translationResult.innerHTML = `
            <div class="translation-loading">
                Translating: ${inputText}...
                <div class="loading-spinner"></div>
            </div>`;

        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer YOUR_OPENROUTER_API_KEY',
                    'HTTP-Referer': 'https://github.com/yourusername/your-repo',
                    'X-Title': 'Japanese Learning App'
                },
                body: JSON.stringify({
                    model: 'meta-llama/llama-4-maverick:free',
                    messages: [{
                        role: 'system',
                        content: `You are a Japanese language expert. Your task is to:
1. Translate the input text to English
2. Break down the translation word by word
3. Explain any grammar points
4. Provide information about any kanji
5. Add any additional context or nuances

Format your response in markdown with clear sections.`
                    }, {
                        role: 'user',
                        content: inputText
                    }]
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const translation = data.choices[0].message.content;

            if (!translation || translation.trim() === '') {
                throw new Error('Empty translation received');
            }

            // Convert markdown to HTML and preserve line breaks
            const formattedTranslation = translation
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');

            translationResult.innerHTML = formattedTranslation;
        } catch (error) {
            translationResult.innerHTML = `
                <div class="translation-error">
                    <div class="error-message">Error translating "${inputText}": ${error.message}</div>
                    <div class="retry-hint">Click to retry</div>
                </div>`;
        }
    }

    // Add click handler for the AI Translation tab
    document.addEventListener('click', function(e) {
        // Check if the clicked element is the AI Translation tab
        if (e.target.closest('#ai-translation')) {
            getAITranslation();
        }
    });
</script>
